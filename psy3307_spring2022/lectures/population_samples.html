<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Populations &amp; Samples</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jonathan A. Pedroza, PhD" />
    <meta name="date" content="2022-02-15" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Populations &amp; Samples
## PSY 3307
### Jonathan A. Pedroza, PhD
### Cal Poly Pomona
### 2022-02-15

---




# Terms

.pull-left[
- sample
  - Xbar is the sample mean
  - S or SD is the sample standard deviation
]

.pull-right[
- population 
  - mu is the population mean
  - sigma is the population standard deviation
]

---

# SPINE of Statistics

- **Standard Error** 

- **Parameters**

- **Interval estimates**

- **Null hypothesis significance testing**

- **Estimation**

---

# Statistical Models

- anything where you are testing predictions between IVs and DV
  - not all models are good models

- **fit** is the degree to which a statistical model represents the data
  - goodness of fit is a common measurement in statistical models (especially higher order models)
  - we'll talk aobut using the sum of squared errors as a measure of fit
  
- all models have some sort of fit

`$$outcome_{i} = (model) + error_{i}$$`

---

.pull-left[
![](population_samples_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;
]

.pull-right[
![](population_samples_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;
]

---

# Populations &amp; Samples

- **population** is the entire number of entities
  - everyone you are interested in studying

- **sample** a smaller subset of the population that you infer things about 
  - the bigger the sample the more it is like the population
  - the sample should be *representative* of the population
  
---

# Populations &amp; Samples

- CPP students
- CPP Psychology Students
- students from each CSU
- males from CPP
- PSY 3307 students

---

# P is for Parameters

- **parameters** are a part of each statistical model
  - parameters are not necessarily measured and are usually constraints to represent some truth about the relationship between IV and DV
  
- parameters are symbols used

- JP Note: parameters can also mean values for any equations using the population only
  - statistics = sample
  - parameters = population

---

# P is for Parameters

- when writing out models, we tend to use the first definition of parameters

- to work out the models below, we estimate the parameters (the values of the b)
  - we'll talk about this later when conducting statistics

`$$outcome_{i} = (model) + error_{i}$$`

---

`$$outcome_{i} = (b{_0}) + error_{i}$$`

`$$outcome_{i} = (b{_0} + b_{1}X_{i}) + error_{i}$$`

`$$outcome_{i} = (b{_0} + b_{1}X_{1i} + + b_{2}X_{2i}) + error_{i}$$`

---

![](population_samples_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

# P is for Parameters

- the values that we are actually calculating are estimates
  - because we are using the sample to estimate what a relationship looks like in a population, we refer to them as **parameter estimates**
  
- this is in hopes that we are seeing that the sample is representative of the population

---

# Mean as a Statistical Model

- b0 is commonly referred to as the intercept
  - it really is just the average value for the outcome
  
---

# Mean as a Statistical Model


```r
(10 + 8 + 4 + 7)/4
```

```
## [1] 7.25
```

`$$outcome_{i} = (b_{0}) + error_{i}$$`

- b0 is the mean of the outcome; here it refers to teacher eval scores
  - we give estimates of our data `hats` to show that we are *estimating* the data, and because they *could, in theory not be true*

`$$outcome_{i} = (\hat{b}_{0}) + error_{i}$$`

---


```r
data_df &lt;- data.frame(eval_values = c(10, 8, 4, 7),
                      mean = c(7.25, 7.25, 7.25, 7.25),
                      deviance = c('', '', '', ''),
                      dev_squared = c('', '', '', ''))
data_df
```

```
##   eval_values mean deviance dev_squared
## 1          10 7.25                     
## 2           8 7.25                     
## 3           4 7.25                     
## 4           7 7.25
```

---

# Assessing Model Fit - Sums of Squares &amp; Variance

- let's use what we have learned with a different lens to see how it relates to modeling
  - **error** is another word for deviance
  
`$$deviance = outcome_{i} - model_{i}$$`
  
`$$outcome_{lecture1} = (\hat{b}_{0}) + error_{lecture1}$$`

- we can use the participant score = the mean estimate of the outcome and the error (deviance)

`$$10 = 7.25 + error_{lecture1}$$`

`$$10-7.25 = error_{lecture1}$$`

`$$2.75 = error_{lecture1}$$`

---




```r
data_df
```

```
##   eval_values mean deviance dev_squared
## 1          10 7.25     2.75      7.5625
## 2           8 7.25     0.75      0.5625
## 3           4 7.25    -3.25     10.5625
## 4           7 7.25    -0.25      0.0625
```

---

.pull-left[
![](population_samples_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

]

.pull-right[
![](population_samples_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;
]
 
---

# Assessing Model Fit - Sums of Squares &amp; Variance

- from the formulas above, we know the fit for the first evaluation

- now we can see the fit overall

`$$total\;error = sum\;of\;errors = \sum_{i = 1}^n(outcome_{i} - model_{i})$$`

`$$\sum_{i = 1}^n(outcome_{i} - model_{i}) = \sum_{i = 1}^n(X_{i} - \overline{X})$$`

---

`$$2.75 + .75 + (-3.25) + (-.25) = 0$$`

---

`$$sum\;of\;squared\;errors (sum\;of\;squares) = \sum_{i = 1}^n(outcome_{i} - model_{i})^2$$`

`$$\sum_{i = 1}^n(outcome_{i} - model_{i})^2 = \sum_{i = 1}^n(X_{i} - \overline{X})^2$$`

---

`$$7.56 + .56 + 10.56 + .06 = 18.75$$`

---

`$$total\;error = \sum_{i = 1}^n(observed_{i} - model_{i})^2$$`

---

`$$mean\;squared\;error = \frac{SS}{df} = \frac{\sum_{i = 1}^n(outcome_{i} - model_{i})^2}{N - 1}$$`

`$$df = N - 1$$`

---

`$$18.75/3 = 6.25$$`

---

# Assessing Model Fit - Sums of Squares &amp; Variance

- to compute average error, we divide sum of squares by the number of values (N), expect we are focusing on the population and how to estimate it
  - **degrees of freedom** is the number of scores used to compute teh total adjusted for the fact that we're estimating the population value

- **mean squared error** is also known as the variance
  - variance is a special case that can be applied to more complex models
  - model fit can be assessed with sum of squared errors or mean squared errors
  
- mean squared error is often seen as how far predicted values (in models) are away from the participants' actual/raw values

---

# E is for Estimating Parameters

- if we wanted to create predictions, we could then include scores to see how well they would fit with the data
  - put numbers in for the squared error that you'd like to test

`$$outcome_{i} = (\hat{b}_{0}) + error_{i}$$`

- we can rearrange this formula to get the error

`$$error_{i} = outcome_{i} - (\hat{b}_{0})$$`

- from this we then test to see the difference between every participant's score and the new value you included (we'll cover this in the activity)
  - then you can add up the squared error values
  - can compare between predictions b1 to b2 values
  - we can then compare the b1, b2, and b0 error values to see which is the best fit
  
---
  
`$$(x_{i} - b_{1})^2$$`

`$$(x_{i} - b_{2})^2$$`

- the process of minimizing the sum of squared errors/sum of squares is know as the **method of least squares** or **ordinary least squares (OLS)**
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
